diff -Naur orig/arch/arm/cpu/armv7/am33xx/board.c a/arch/arm/cpu/armv7/am33xx/board.c
--- orig/arch/arm/cpu/armv7/am33xx/board.c	2012-12-16 20:53:52.000000000 +0100
+++ a/arch/arm/cpu/armv7/am33xx/board.c	2014-06-10 17:39:48.352694513 +0200
@@ -57,8 +57,9 @@
 const struct gpio_bank *const omap_gpio_bank = gpio_bank_am33xx;
 
 /* MII mode defines */
-#define MII_MODE_ENABLE		0x0
-#define RGMII_MODE_ENABLE	0xA
+#define MII_MODE_ENABLE		0x00
+#define RMII_MODE_ENABLE	0xC5//ESA
+#define RGMII_MODE_ENABLE	0x0A
 
 /* GPIO that controls power to DDR on EVM-SK */
 #define GPIO_DDR_VTT_EN		7
@@ -319,6 +320,10 @@
 		/* Set MPU Frequency to 720MHz */
 		mpu_pll_config(MPUPLL_M_720);
 	} else {
+#ifdef PENGWYN
+		//puts( "Set PLL to 720MHz\n");
+		mpu_pll_config(MPUPLL_M_720);
+#else//!PENGWYN
 		uchar buf[4];
 		/*
 		 * EVM PMIC code.  All boards currently want an MPU voltage
@@ -344,6 +349,7 @@
 			else
 	 			mpu_pll_config(MPUPLL_M_720);
 		}
+#endif//!PENGWYN
 	}
 }
 #endif
@@ -414,6 +420,13 @@
 	preloader_console_init();
 #endif
 
+#ifdef PENGWYN
+	header.magic = 0xEE3355AA;
+	strncpy(header.name, "A335X_SK", HDR_NAME_LEN);
+	enable_board_pin_mux(&header);
+	am33xx_spl_board_init();
+	config_ddr(EMIF_REG_SDRAM_TYPE_DDR3);
+#else//!PENGWYN
 	/* Initalize the board header */
 	enable_i2c0_pin_mux();
 	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
@@ -475,6 +488,8 @@
 		config_ddr(EMIF_REG_SDRAM_TYPE_DDR3);
 	else
 		config_ddr(EMIF_REG_SDRAM_TYPE_DDR2);
+#endif//!PENGWYN
+
 #endif
 }
 
@@ -580,9 +595,11 @@
  */
 int board_init(void)
 {
+#ifndef PENGWYN
 	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
 	if (read_eeprom() < 0)
 		puts("Could not get board ID.\n");
+#endif
 
 	gd->bd->bi_boot_params = PHYS_DRAM_1 + 0x100;
 
@@ -604,31 +621,36 @@
 	{
 		.slave_reg_ofs	= 0x208,
 		.sliver_reg_ofs	= 0xd80,
-		.phy_id		= 0,
+		.phy_id		    = 0,
 	},
 	{
 		.slave_reg_ofs	= 0x308,
 		.sliver_reg_ofs	= 0xdc0,
-		.phy_id		= 1,
+//ESA		.phy_id		    = 1,
+		.phy_id		    = 7,
 	},
 };
 
 static struct cpsw_platform_data cpsw_data = {
-	.mdio_base		= AM335X_CPSW_MDIO_BASE,
-	.cpsw_base		= AM335X_CPSW_BASE,
-	.mdio_div		= 0xff,
-	.channels		= 8,
-	.cpdma_reg_ofs		= 0x800,
-	.slaves			= 1,
-	.slave_data		= cpsw_slaves,
+	.mdio_base		    = AM335X_CPSW_MDIO_BASE,
+	.cpsw_base		    = AM335X_CPSW_BASE,
+	.mdio_div		    = 0xff,
+	.channels		    = 8,
+	.cpdma_reg_ofs	    = 0x800,
+//ESA #ifdef PENGWYN
+//ESA	.slaves			= 2,
+//ESA #else
+	.slaves			    = 1,
+//ESA #endif
+	.slave_data		    = cpsw_slaves,
 	.ale_reg_ofs		= 0xd00,
 	.ale_entries		= 1024,
 	.host_port_reg_ofs	= 0x108,
 	.hw_stats_reg_ofs	= 0x900,
 	.mac_control		= (1 << 5),
-	.control		= cpsw_control,
+	.control		    = cpsw_control,
 	.host_port_num		= 0,
-	.version		= CPSW_CTRL_VERSION_2,
+	.version		    = CPSW_CTRL_VERSION_2,
 };
 #endif
 
@@ -649,6 +671,7 @@
 	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
 	mac_addr[4] = mac_lo & 0xFF;
 	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+	//printf("MAC %x %x %x %x %x %x\n",mac_addr[0],mac_addr[1],mac_addr[2],mac_addr[3],mac_addr[4],mac_addr[5]);
 
 #if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
 	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
@@ -672,6 +695,17 @@
 		}
 	}
 
+#ifdef PENGWYN
+//ESA	cpsw_slaves[0].phy_id = 1;
+//ESA	cpsw_slaves[1].phy_id = 0;
+//ESA	cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if = PHY_INTERFACE_MODE_MII;
+//ESA	writel(MII_MODE_ENABLE, &cdev->miisel);
+
+	printf("Set MII mode %x,%lx = %x\n",RMII_MODE_ENABLE,&cdev->miisel,cdev->miisel);
+	cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if = PHY_INTERFACE_MODE_RMII;
+	writel(RMII_MODE_ENABLE, &cdev->miisel);
+
+#else
 	if (board_is_bone()) {
 		writel(MII_MODE_ENABLE, &cdev->miisel);
 		cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
@@ -681,6 +715,7 @@
 		cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
 				PHY_INTERFACE_MODE_RGMII;
 	}
+#endif
 
 	rv = cpsw_register(&cpsw_data);
 	if (rv < 0) {
@@ -713,3 +748,4 @@
 	return ret;
 }
 #endif
+
diff -Naur orig/arch/arm/include/asm/arch-am33xx/cpu.h a/arch/arm/include/asm/arch-am33xx/cpu.h
--- orig/arch/arm/include/asm/arch-am33xx/cpu.h	2012-12-16 20:53:52.000000000 +0100
+++ a/arch/arm/include/asm/arch-am33xx/cpu.h	2014-06-10 17:39:36.618830175 +0200
@@ -78,6 +78,15 @@
 	u32 bch_result_x[4];
 };
 
+//#ifdef	PENGWYN
+struct bch_result2 {
+	u32 bch_result_x_4;
+	u32 bch_result_x_5;
+	u32 bch_result_x_6;
+	u32 bch_result_x_res;
+};
+//#endif
+
 struct gpmc {
 	u8 res1[0x10];
 	u32 sysconfig;		/* 0x10 */
@@ -107,7 +116,15 @@
 	u8 res7[12];		/* 0x224 */
 	u32 testmomde_ctrl;	/* 0x230 */
 	u8 res8[12];		/* 0x234 */
-	struct bch_res_0_3 bch_result_0_3[2];	/* 0x240 */
+//#ifdef PENGWN
+	struct bch_res_0_3 bch_result_0_3[8];	/* 0x240 */
+	u32 res9[4];							/* 0x2C0 */
+	u32 gpmc_bch_swdata;					/* 0x2D0 */
+	u32 res10[11];							/* 0x2D4 */
+	struct bch_result2 bch_result_8_F[8];	/* 0x300 */
+//#else
+//	struct bch_res_0_3 bch_result_0_3[2];	/* 0x240 */
+//#endif
 };
 
 /* Used for board specific gpmc initialization */
diff -Naur orig/arch/arm/include/asm/arch-am33xx/ddr_defs.h a/arch/arm/include/asm/arch-am33xx/ddr_defs.h
--- orig/arch/arm/include/asm/arch-am33xx/ddr_defs.h	2012-12-16 20:53:52.000000000 +0100
+++ a/arch/arm/include/asm/arch-am33xx/ddr_defs.h	2014-06-10 18:08:55.728397356 +0200
@@ -48,20 +48,20 @@
 #define DDR2_IOCTRL_VALUE	0x18B
 
 /* Micron MT41J128M16JT-125 */
-#define DDR3_EMIF_READ_LATENCY	0x100006	/* Enable Dynamic Power Down */
-#define DDR3_EMIF_TIM1		0x0888A39B
-#define DDR3_EMIF_TIM2		0x26337FDA
-#define DDR3_EMIF_TIM3		0x501F830F
-#define DDR3_EMIF_SDCFG		0x61C04AB2
-#define DDR3_EMIF_SDREF		0x0000093B
-#define DDR3_ZQ_CFG		0x50074BE4
+#define DDR3_EMIF_READ_LATENCY	0x000007 	/* Enable Dynamic Power Down */
+#define DDR3_EMIF_TIM1		0x0AAAD4DB
+#define DDR3_EMIF_TIM2		0x266B7FDA
+#define DDR3_EMIF_TIM3		0x501F867F
+#define DDR3_EMIF_SDCFG		0x61c05332
+#define DDR3_EMIF_SDREF		0x00000C30
+#define DDR3_ZQ_CFG		    0x50074BE4
 #define DDR3_DLL_LOCK_DIFF	0x1
-#define DDR3_RATIO		0x40
+#define DDR3_RATIO		    0xA0
 #define DDR3_INVERT_CLKOUT	0x1
-#define DDR3_RD_DQS		0x3B
-#define DDR3_WR_DQS		0x85
-#define DDR3_PHY_WR_DATA	0xC1
-#define DDR3_PHY_FIFO_WE	0x100
+#define DDR3_RD_DQS		    0x29
+#define DDR3_WR_DQS		    0x82
+#define DDR3_PHY_WR_DATA	0xBE
+#define DDR3_PHY_FIFO_WE	0xFF
 #define DDR3_IOCTRL_VALUE	0x18B
 
 /* Micron ???? on 1.5 and later EVMs */
diff -Naur orig/arch/arm/include/asm/arch-am33xx/omap_gpmc.h a/arch/arm/include/asm/arch-am33xx/omap_gpmc.h
--- orig/arch/arm/include/asm/arch-am33xx/omap_gpmc.h	2012-12-16 20:53:52.000000000 +0100
+++ a/arch/arm/include/asm/arch-am33xx/omap_gpmc.h	2014-06-10 17:39:36.618830175 +0200
@@ -117,4 +117,39 @@
 		{.offset = 106,\
 		 .length = 8 } } \
 }
+
+#define GPMC_1G_NAND_HW_BCH8_ECC_LAYOUT {\
+	.eccbytes = 112,\
+	.eccpos = {  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,	16, 17,\
+				18, 19, 20, 21, 22, 23, 24, 25, 26, 27,	28, 29, 30, 31, 32, 33,\
+				34, 35, 36, 37, 38, 39,	40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
+				50, 51,	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,	63, 64, 65,\
+				66, 67, 68, 69, 70, 71, 72, 73, 74,	75, 76, 77, 78, 79, 80, 81,\
+				82, 83, 84, 85, 86,	87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,\
+				98,	99,100,101,102,103,104,105,106,107,108,109,110,111,112,113},\
+	.oobfree = {\
+		{.offset = 114,\
+		 .length = 110 } } \
+}
+
+#define GPMC_1G_NAND_HW_BCH16_ECC_LAYOUT {\
+	.eccbytes = 208,\
+	.eccpos = {  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,	16, 17,\
+				18, 19, 20, 21, 22, 23, 24, 25, 26, 27,	28, 29, 30, 31, 32, 33,\
+				34, 35, 36, 37, 38, 39,	40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
+				50, 51,	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,	63, 64, 65,\
+				66, 67, 68, 69, 70, 71, 72, 73, 74,	75, 76, 77, 78, 79, 80, 81,\
+				82, 83, 84, 85, 86,	87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,\
+				98,	99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,\
+				114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,\
+				134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,\
+				154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,\
+				174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,\
+				194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209},\
+	.oobfree = {\
+		{.offset = 210,\
+		 .length = 14 } } \
+}
+
 #endif /* __ASM_ARCH_OMAP_GPMC_H */
+
diff -Naur orig/board/silica/pengwyn/Makefile a/board/silica/pengwyn/Makefile
--- orig/board/silica/pengwyn/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ a/board/silica/pengwyn/Makefile	2014-06-10 17:39:36.618830175 +0200
@@ -0,0 +1,45 @@
+#
+# Makefile
+#
+# Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed "as is" WITHOUT ANY WARRANTY of any
+# kind, whether express or implied; without even the implied warranty
+# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_NOR_BOOT),y)
+COBJS	:= mux.o
+endif
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Naur orig/board/silica/pengwyn/mux.c a/board/silica/pengwyn/mux.c
--- orig/board/silica/pengwyn/mux.c	1970-01-01 01:00:00.000000000 +0100
+++ a/board/silica/pengwyn/mux.c	2014-06-10 17:39:48.352694513 +0200
@@ -0,0 +1,587 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+#include <i2c.h>
+
+#define MUX_CFG(value, offset)	\
+	__raw_writel(value, (CTRL_BASE + offset));
+
+/* PAD Control Fields */
+#define SLEWCTRL	(0x1 << 6)
+#define RXACTIVE	(0x1 << 5)
+#define PULLUP_EN	(0x1 << 4) /* Pull UP Selection */
+#define PULLUDEN	(0x0 << 3) /* Pull up enabled */
+#define PULLUDDIS	(0x1 << 3) /* Pull up disabled */
+#define MODE(val)	val	/* used for Readability */
+
+/*
+ * PAD CONTROL OFFSETS
+ * Field names corresponds to the pad signal name
+ * Note: CONTROL_MODULE REGISTERS, offset 800h 
+ */
+struct pad_signals {
+	int gpmc_ad0;
+	int gpmc_ad1;
+	int gpmc_ad2;
+	int gpmc_ad3;
+	int gpmc_ad4;
+	int gpmc_ad5;
+	int gpmc_ad6;
+	int gpmc_ad7;
+	int gpmc_ad8;
+	int gpmc_ad9;
+	int gpmc_ad10;
+	int gpmc_ad11;
+	int gpmc_ad12;
+	int gpmc_ad13;
+	int gpmc_ad14;
+	int gpmc_ad15;
+	int gpmc_a0;            // gpio1_16 RMII2_TXEN   R13
+	int gpmc_a1;
+	int gpmc_a2;
+	int gpmc_a3;
+	int gpmc_a4;            // gpio1_20 RMII2_TXD1   R14
+	int gpmc_a5;            // gpio1_21 RMII2_TXD0   V15
+	int gpmc_a6;
+	int gpmc_a7;
+	int gpmc_a8;
+	int gpmc_a9;
+	int gpmc_a10;           // gpio1_26 RMII2_RXD1   T16
+	int gpmc_a11;           // gpio1_27 RMII2_RXD0   V17
+	int gpmc_wait0;
+	int gpmc_wpn;           // gpio0_31 RMII2_RXER   U17
+	int gpmc_be1n;          // gpio1_28 GPMC_BEn1    U18
+	int gpmc_csn0;
+	int gpmc_csn1;
+	int gpmc_csn2;
+	int gpmc_csn3;          // gpio2_0  RMII2_CRS_DV T13
+	int gpmc_clk;
+	int gpmc_advn_ale;
+	int gpmc_oen_ren;
+	int gpmc_wen;
+	int gpmc_be0n_cle;
+	int lcd_data0;
+	int lcd_data1;
+	int lcd_data2;
+	int lcd_data3;
+	int lcd_data4;
+	int lcd_data5;
+	int lcd_data6;
+	int lcd_data7;
+	int lcd_data8;
+	int lcd_data9;
+	int lcd_data10;
+	int lcd_data11;
+	int lcd_data12;
+	int lcd_data13;
+	int lcd_data14;
+	int lcd_data15;
+	int lcd_vsync;
+	int lcd_hsync;
+	int lcd_pclk;
+	int lcd_ac_bias_en;
+	int mmc0_dat3;
+	int mmc0_dat2;
+	int mmc0_dat1;
+	int mmc0_dat0;
+	int mmc0_clk;
+	int mmc0_cmd;
+	int mii1_col;           // gpio3_0  MII1_COL    H16
+	int mii1_crs;           // gpio3_1  MII1_CRS_DV H17
+	int mii1_rxerr;         // gpio3_2  MII1_RXE    J15
+	int mii1_txen;          // gpio3_3  MII1_TXEN   J16
+	int mii1_rxdv;          // gpio3_4  MII1_RXDV   J17
+	int mii1_txd3;          // gpio0_16 MII1_TXD3   J18
+	int mii1_txd2;          // gpio0_17 MII1_TXD2   K15
+	int mii1_txd1;          // gpio0_21 MII1_TXD1   K16
+	int mii1_txd0;          // gpio0_28 MII1_TXD0   K17
+	int mii1_txclk;         // gpio3_9  MII1_TXCLK  K18
+	int mii1_rxclk;         // gpio3_10 MII1_RXCLK  L18
+	int mii1_rxd3;          // gpio2_18 MII1_RXD3   L17
+	int mii1_rxd2;          // gpio2_19 MII1_RXD2   L16
+	int mii1_rxd1;          // gpio2_20 MII1_RXD1   L15
+	int mii1_rxd0;          // gpio2_21 MII1_RXD0   M16
+	int rmii1_refclk;       // gpio0_29 MII1_REFCLK H18
+	int mdio_data;          // gpio0_1  MDIO_CLK    M18
+	int mdio_clk;           // gpio0_0  MDIO_DATA   M17
+	int spi0_sclk;
+	int spi0_d0;
+	int spi0_d1;
+	int spi0_cs0;
+	int spi0_cs1;
+	int ecap0_in_pwm0_out;
+	int uart0_ctsn;
+	int uart0_rtsn;
+	int uart0_rxd;
+	int uart0_txd;
+	int uart1_ctsn;
+	int uart1_rtsn;
+	int uart1_rxd;
+	int uart1_txd;
+	int i2c0_sda;
+	int i2c0_scl;
+	int mcasp0_aclkx;
+	int mcasp0_fsx;
+	int mcasp0_axr0;
+	int mcasp0_ahclkr;
+	int mcasp0_aclkr;
+	int mcasp0_fsr;
+	int mcasp0_axr1;
+	int mcasp0_ahclkx;
+	int xdma_event_intr0;
+	int xdma_event_intr1;
+	int nresetin_out;
+	int porz;
+	int nnmi;
+	int osc0_in;
+	int osc0_out;
+	int rsvd1;
+	int tms;
+	int tdi;
+	int tdo;
+	int tck;
+	int ntrst;
+	int emu0;
+	int emu1;
+	int osc1_in;
+	int osc1_out;
+	int pmic_power_en;
+	int rtc_porz;
+	int rsvd2;
+	int ext_wakeup;
+	int enz_kaldo_1p8v;
+	int usb0_dm;
+	int usb0_dp;
+	int usb0_ce;
+	int usb0_id;
+	int usb0_vbus;
+	int usb0_drvvbus;
+	int usb1_dm;
+	int usb1_dp;
+	int usb1_ce;
+	int usb1_id;
+	int usb1_vbus;
+	int usb1_drvvbus;
+	int ddr_resetn;
+	int ddr_csn0;
+	int ddr_cke;
+	int ddr_ck;
+	int ddr_nck;
+	int ddr_casn;
+	int ddr_rasn;
+	int ddr_wen;
+	int ddr_ba0;
+	int ddr_ba1;
+	int ddr_ba2;
+	int ddr_a0;
+	int ddr_a1;
+	int ddr_a2;
+	int ddr_a3;
+	int ddr_a4;
+	int ddr_a5;
+	int ddr_a6;
+	int ddr_a7;
+	int ddr_a8;
+	int ddr_a9;
+	int ddr_a10;
+	int ddr_a11;
+	int ddr_a12;
+	int ddr_a13;
+	int ddr_a14;
+	int ddr_a15;
+	int ddr_odt;
+	int ddr_d0;
+	int ddr_d1;
+	int ddr_d2;
+	int ddr_d3;
+	int ddr_d4;
+	int ddr_d5;
+	int ddr_d6;
+	int ddr_d7;
+	int ddr_d8;
+	int ddr_d9;
+	int ddr_d10;
+	int ddr_d11;
+	int ddr_d12;
+	int ddr_d13;
+	int ddr_d14;
+	int ddr_d15;
+	int ddr_dqm0;
+	int ddr_dqm1;
+	int ddr_dqs0;
+	int ddr_dqsn0;
+	int ddr_dqs1;
+	int ddr_dqsn1;
+	int ddr_vref;
+	int ddr_vtp;
+	int ddr_strben0;
+	int ddr_strben1;
+	int ain7;
+	int ain6;
+	int ain5;
+	int ain4;
+	int ain3;
+	int ain2;
+	int ain1;
+	int ain0;
+	int vrefp;
+	int vrefn;
+};
+
+struct module_pin_mux {
+	short reg_offset;
+	unsigned char val;
+};
+
+/* Pad control register offset */
+#define PAD_CTRL_BASE	0x800
+#define OFFSET(x)	(unsigned int) (&((struct pad_signals *) \
+				(PAD_CTRL_BASE))->x)
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux_sk_evm[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux_pengwyn[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkx),(MODE(4) | RXACTIVE | PULLUP_EN)},/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(gpmc_csn0), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(gpmc_advn_ale), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_CD */
+	{-1},
+};
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(spi0_d1), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(spi0_cs0), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_CS0 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_7_pin_mux[] = {
+	{OFFSET(ecap0_in_pwm0_out), (MODE(7) | PULLUDEN)},	/* GPIO0_7 */
+	{-1},
+};
+
+static struct module_pin_mux rgmii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* RGMII1_TCTL */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* RGMII1_RCTL */
+	{OFFSET(mii1_txd3), MODE(2)},			/* RGMII1_TD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* RGMII1_TD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* RGMII1_TD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* RGMII1_TD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* RGMII1_TCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+//ESA rmii1_pin_mux
+static struct module_pin_mux rmii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(1) | RXACTIVE},	/* RMII1_RXERR */
+	{OFFSET(mii1_txen), MODE(1)},			    /* RMII1_TXEN */
+//ESA	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+//ESA	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+//ESA	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(1)},			    /* RMII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(1)},			    /* RMII1_TXD0 */
+//ESA	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+//ESA	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+//ESA	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+//ESA	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(1) | RXACTIVE},	/* RMII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(1) | RXACTIVE},	/* RMII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{OFFSET(mii1_crs), MODE(1) | RXACTIVE},     /* gpio3_1  MII1_CRS_DV  H17 */
+	{OFFSET(rmii1_refclk), MODE(0) | RXACTIVE}, /* gpio0_29 MII1_REFCLK  H18 */
+	{-1},
+};
+
+static struct module_pin_mux rmii2_pin_mux[] = {//ESA
+	{OFFSET(gpmc_wpn), MODE(3) | RXACTIVE},     /* gpio0_31 RMII2_RXER   U17 */
+	{OFFSET(gpmc_a0), MODE(3)},	        		/* gpio1_16 RMII2_TXEN   R13 */
+	{OFFSET(gpmc_a4), MODE(3)},	        		/* gpio1_20 RMII2_TXD1   R14 */
+	{OFFSET(gpmc_a5), MODE(3)},	        		/* gpio1_21 RMII2_TXD0   V15 */
+	{OFFSET(gpmc_a10), MODE(3) | RXACTIVE}, 	/* gpio1_26 RMII2_RXD1   T16 */
+	{OFFSET(gpmc_a11), MODE(3) | RXACTIVE}, 	/* gpio1_27 RMII2_RXD0   V17 */
+	{OFFSET(gpmc_csn3), MODE(2) | RXACTIVE}, 	/* gpio2_0  RMII2_CRS_DV T13 */
+	{OFFSET(mii1_col), MODE(1) | RXACTIVE}, 	/* gpio3_0  RMII2_REFCLK H16 */
+	{-1},
+};
+
+
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD0 */
+	{OFFSET(gpmc_ad1), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD1 */
+	{OFFSET(gpmc_ad2), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD2 */
+	{OFFSET(gpmc_ad3), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD3 */
+	{OFFSET(gpmc_ad4), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD4 */
+	{OFFSET(gpmc_ad5), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD5 */
+	{OFFSET(gpmc_ad6), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD6 */
+	{OFFSET(gpmc_ad7), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* NAND AD7 */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)}, /* NAND WAIT */
+//ESA	{OFFSET(gpmc_wpn), (MODE(7) | PULLUP_EN | RXACTIVE)},	/* NAND_WPN */
+	{OFFSET(gpmc_be1n), (MODE(7) | PULLUP_EN | RXACTIVE)},	/* NAND_WPN */ // gpio1_28 GPMC_BEn1    U18
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN)},	/* NAND_CS0 */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN)}, /* NAND_ADV_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN)},	/* NAND_OE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN)},	/* NAND_WEN */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN)},	/* NAND_BE_CLE */
+	{-1},
+};
+
+#if defined(CONFIG_NOR) && !defined(CONFIG_NOR_BOOT)
+static struct module_pin_mux bone_norcape_pin_mux[] = {
+	{OFFSET(lcd_data0), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A0 */
+	{OFFSET(lcd_data1), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A1 */
+	{OFFSET(lcd_data2), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A2 */
+	{OFFSET(lcd_data3), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A3 */
+	{OFFSET(lcd_data4), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A4 */
+	{OFFSET(lcd_data5), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A5 */
+	{OFFSET(lcd_data6), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A6 */
+	{OFFSET(lcd_data7), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A7 */
+	{OFFSET(lcd_vsync), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A8 */
+	{OFFSET(lcd_hsync), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A9 */
+	{OFFSET(lcd_pclk), MODE(1)| PULLUDEN | RXACTIVE},	/* NOR_A10 */
+	{OFFSET(lcd_ac_bias_en), MODE(1)| PULLUDEN | RXACTIVE},	/* NOR_A11 */
+	{OFFSET(lcd_data8), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A12 */
+	{OFFSET(lcd_data9), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A13 */
+	{OFFSET(lcd_data10), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A14 */
+	{OFFSET(lcd_data11), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A15 */
+	{OFFSET(lcd_data12), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A16 */
+	{OFFSET(lcd_data13), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A17 */
+	{OFFSET(lcd_data14), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A18 */
+	{OFFSET(lcd_data15), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A19 */
+	{OFFSET(gpmc_ad0), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD15 */
+
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN) | RXACTIVE},	/* NOR_CE */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN) | RXACTIVE}, /* NOR_ADVN_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN | RXACTIVE)},/* NOR_OE */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN | RXACTIVE)},/* NOR_BE0N_CLE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN | RXACTIVE)},	/* NOR_WEN */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUDEN)}, /* NOR WAIT */
+	{-1},
+};
+#endif
+
+/*
+ * Configure the pin mux for the module
+ */
+static void configure_module_pin_mux(struct module_pin_mux *mod_pin_mux)
+{
+	int i;
+
+	if (!mod_pin_mux)
+		return;
+
+	for (i = 0; mod_pin_mux[i].reg_offset != -1; i++)
+		MUX_CFG(mod_pin_mux[i].val, mod_pin_mux[i].reg_offset);
+}
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
+
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+/*
+ * The AM335x GP EVM, if daughter card(s) are connected, can have 8
+ * different profiles.  These profiles determine what peripherals are
+ * valid and need pinmux to be configured.
+ */
+#define PROFILE_NONE	0x0
+#define PROFILE_0	(1 << 0)
+#define PROFILE_1	(1 << 1)
+#define PROFILE_2	(1 << 2)
+#define PROFILE_3	(1 << 3)
+#define PROFILE_4	(1 << 4)
+#define PROFILE_5	(1 << 5)
+#define PROFILE_6	(1 << 6)
+#define PROFILE_7	(1 << 7)
+#define PROFILE_MASK	0x7
+#define PROFILE_ALL	0xFF
+
+/* CPLD registers */
+#define I2C_CPLD_ADDR	0x35
+#define CFG_REG		0x10
+
+static unsigned short detect_daughter_board_profile(void)
+{
+	unsigned short val;
+
+	if (i2c_probe(I2C_CPLD_ADDR))
+		return PROFILE_NONE;
+
+	if (i2c_read(I2C_CPLD_ADDR, CFG_REG, 1, (unsigned char *)(&val), 2))
+		return PROFILE_NONE;
+
+	return (1 << (val & PROFILE_MASK));
+}
+
+void enable_board_pin_mux(struct am335x_baseboard_id *header)
+{
+#ifdef PENGWYN
+//ESA	puts("Configure Pengwyn...\n");
+//ESA	configure_module_pin_mux(mii1_pin_mux);
+	puts("Configure ESAWARE...\n");
+	configure_module_pin_mux(rmii1_pin_mux);//ESA
+	configure_module_pin_mux(rmii2_pin_mux);//ESA
+	configure_module_pin_mux(mmc0_pin_mux_pengwyn);
+	configure_module_pin_mux(nand_pin_mux);
+#else
+	/* Do board-specific muxes. */
+	if (!strncmp(header->name, "A335BONE", HDR_NAME_LEN)) {
+		/* Beaglebone pinmux */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NOR) && !defined(CONFIG_NOR_BOOT)
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#endif
+	} else if (!strncmp(header->config, "SKU#01", 6)) {
+		/* General Purpose EVM */
+		unsigned short profile = detect_daughter_board_profile();
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+		/* In profile #2 i2c1 and spi0 conflict. */
+		if (profile & ~PROFILE_2)
+			configure_module_pin_mux(i2c1_pin_mux);
+		/* Profiles 2 & 3 don't have NAND */
+		if (profile & ~(PROFILE_2 | PROFILE_3))
+			configure_module_pin_mux(nand_pin_mux);
+		else if (profile == PROFILE_2) {
+			configure_module_pin_mux(mmc1_pin_mux);
+			configure_module_pin_mux(spi0_pin_mux);
+		}
+	} else if (!strncmp(header->name, "A335X_SK", HDR_NAME_LEN)) {
+		/* Starter Kit EVM */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(gpio0_7_pin_mux);
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+	} else {
+		puts("Unknown board, cannot configure pinmux.");
+		hang();
+	}
+#endif
+}
+
diff -Naur orig/boards.cfg a/boards.cfg
--- orig/boards.cfg	2012-12-16 20:53:53.000000000 +0100
+++ a/boards.cfg	2014-06-10 17:39:36.626834175 +0200
@@ -235,6 +235,7 @@
 am335x_evm_restore_flash_uart_usbspl arm armv7       am335x              ti             am33xx      am335x_evm:RESTORE_FLASH,UART_THEN_USB_SPL,USB_SPL
 am335x_evm_usbspl       arm         armv7       am335x              ti             am33xx      am335x_evm:USB_SPL
 am335x_evm_restore_flash_usbspl arm armv7       am335x              ti             am33xx      am335x_evm:RESTORE_FLASH,USB_SPL
+pengwyn                      arm         armv7       pengwyn             silica         am33xx      pengwyn:DFU_NAND
 highbank                     arm         armv7       highbank            -              highbank
 mx51_efikamx                 arm         armv7       mx51_efikamx        genesi         mx5		mx51_efikamx:MACH_TYPE=MACH_TYPE_MX51_EFIKAMX,IMX_CONFIG=board/genesi/mx51_efikamx/imximage_mx.cfg
 mx51_efikasb                 arm         armv7       mx51_efikamx        genesi         mx5		mx51_efikamx:MACH_TYPE=MACH_TYPE_MX51_EFIKASB,IMX_CONFIG=board/genesi/mx51_efikamx/imximage_sb.cfg
diff -Naur orig/common/miiphyutil.c a/common/miiphyutil.c
--- orig/common/miiphyutil.c	2012-12-16 20:53:53.000000000 +0100
+++ a/common/miiphyutil.c	2014-06-10 17:39:36.630836175 +0200
@@ -112,6 +112,7 @@
 {
 	struct mii_dev *new_dev;
 	struct legacy_mii_dev *ldev;
+printf(">>>miiphy_register\n");
 
 	BUG_ON(strlen(name) >= MDIO_NAME_LEN);
 
diff -Naur orig/common/spl/spl_nand.c a/common/spl/spl_nand.c
--- orig/common/spl/spl_nand.c	2012-12-16 20:53:53.000000000 +0100
+++ a/common/spl/spl_nand.c	2014-06-10 17:39:36.630836175 +0200
@@ -98,3 +98,4 @@
 		spl_image.size, (void *)spl_image.load_addr);
 	nand_deselect();
 }
+
diff -Naur orig/drivers/mtd/nand/nand_base.c a/drivers/mtd/nand/nand_base.c
--- orig/drivers/mtd/nand/nand_base.c	2012-12-16 20:53:53.000000000 +0100
+++ a/drivers/mtd/nand/nand_base.c	2014-06-10 17:39:36.630836175 +0200
@@ -233,8 +233,10 @@
 	struct nand_chip *chip = mtd->priv;
 
 	for (i = 0; i < len; i++)
+{
 		writeb(buf[i], chip->IO_ADDR_W);
 }
+}
 
 /**
  * nand_read_buf - [DEFAULT] read chip data into buffer
@@ -1463,6 +1465,7 @@
 	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
 	const uint8_t *bufpoi = chip->oob_poi;
 
+
 	/*
 	 * data-ecc-data-ecc ... ecc-oob
 	 * or
diff -Naur orig/drivers/mtd/nand/nand_bbt.c a/drivers/mtd/nand/nand_bbt.c
--- orig/drivers/mtd/nand/nand_bbt.c	2012-12-16 20:53:53.000000000 +0100
+++ a/drivers/mtd/nand/nand_bbt.c	2014-06-10 17:39:36.634838175 +0200
@@ -166,7 +166,10 @@
 	/* Compare the pattern */
 	for (i = 0; i < td->len; i++) {
 		if (p[td->offs + i] != td->pattern[i])
+{
+printf("check_short_pattern %d<%d,%d,%d!=%d\n",i,td->len,td->offs,p[td->offs + i],td->pattern[i]);
 			return -1;
+}
 	}
 	/* Need to check location 1 AND 6? */
 	if (td->options & NAND_BBT_SCANBYTE1AND6) {
@@ -480,10 +483,16 @@
 		 */
 		ret = mtd->read_oob(mtd, offs, &ops);
 		if (ret)
+{
+printf("ret=ooblen=%d %d offs=%d\n", mtd->oobsize, ops.ooblen, offs );
 			return ret;
+}
 
 		if (check_short_pattern(buf, bd))
+{
+printf("check_short_pattern=ooblen=%d %d offs=%d\n", mtd->oobsize, ops.ooblen, offs );
 			return 1;
+}
 
 		offs += mtd->writesize;
 	}
@@ -1434,6 +1443,9 @@
 
 	MTDDEBUG(MTD_DEBUG_LEVEL2, "nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\n",
 	      (unsigned int)offs, block >> 1, res);
+if (res)
+printf("nand_isbad_bbt(): bbt info for offs 0x%08x: (bbt=%lx) (block %d) 0x%02x\n",
+	      (unsigned int)offs, this->bbt, block >> 1, res);
 
 	switch ((int)res) {
 	case 0x00:
diff -Naur orig/drivers/mtd/nand/nand_ids.c a/drivers/mtd/nand/nand_ids.c
--- orig/drivers/mtd/nand/nand_ids.c	2012-12-16 20:53:53.000000000 +0100
+++ a/drivers/mtd/nand/nand_ids.c	2014-06-10 17:39:36.634838175 +0200
@@ -109,6 +109,9 @@
 	{"NAND 1GiB 3,3V 8-bit",	0xD3, 0, 1024, 0, LP_OPTIONS},
 	{"NAND 1GiB 1,8V 16-bit",	0xB3, 0, 1024, 0, LP_OPTIONS16},
 	{"NAND 1GiB 3,3V 16-bit",	0xC3, 0, 1024, 0, LP_OPTIONS16},
+#ifdef PENGWYN
+	{"NAND 1GiB 3,3V 8-bit",	0x38, 0, 1024, 0, LP_OPTIONS}, // MICRON MT29F8G08ABACAWP
+#endif
 
 	/* 16 Gigabit */
 	{"NAND 2GiB 1,8V 8-bit",	0xA5, 0, 2048, 0, LP_OPTIONS},
diff -Naur orig/drivers/mtd/nand/omap_gpmc.c a/drivers/mtd/nand/omap_gpmc.c
--- orig/drivers/mtd/nand/omap_gpmc.c	2012-12-16 20:53:53.000000000 +0100
+++ a/drivers/mtd/nand/omap_gpmc.c	2014-06-10 17:39:36.634838175 +0200
@@ -258,6 +258,16 @@
 #define ECC_BCH8_NIBBLES	26
 #define ECC_BCH16_NIBBLES	52
 
+#ifdef PENGWYN
+//static struct nand_ecclayout hw_bch8_nand_oob = GPMC_1G_NAND_HW_BCH8_ECC_LAYOUT;
+static struct nand_ecclayout hw_bch16_nand_oob = GPMC_1G_NAND_HW_BCH16_ECC_LAYOUT;
+
+static struct nand_bch_priv bch_priv = {
+	.mode = NAND_ECC_HW_BCH,
+	.type = ECC_BCH16,
+	.nibbles = ECC_BCH16_NIBBLES
+};
+#else
 static struct nand_ecclayout hw_bch8_nand_oob = GPMC_NAND_HW_BCH8_ECC_LAYOUT;
 
 static struct nand_bch_priv bch_priv = {
@@ -265,6 +275,7 @@
 	.type = ECC_BCH8,
 	.nibbles = ECC_BCH8_NIBBLES
 };
+#endif
 
 /*
  * omap_read_bch8_result - Read BCH result for BCH8 level
@@ -304,6 +315,48 @@
 	}
 }
 
+#ifdef PENGWYN
+/*
+ * omap_read_bch16_result - Read BCH result for BCH16 level (total 26 bytes)
+ *
+ * @mtd:	MTD device structure
+ * @big_endian:	When set read register 3 first
+ * @ecc_code:	Read syndrome from BCH result registers
+ */
+static void omap_read_bch16_result(struct mtd_info *mtd, uint8_t big_endian,
+				uint8_t *ecc_code)
+{
+	uint32_t *ptr;
+	int8_t i = 0, j;
+
+	if (big_endian) {
+		ptr = &gpmc_cfg->bch_result_8_F[0].bch_result_x_6;
+		ecc_code[i++] = (readl(ptr) >>  8) & 0xFF;
+		ecc_code[i++] = readl(ptr) & 0xFF;
+		ptr--;
+		for (j = 0; j < 2; j++) {
+			ecc_code[i++] = (readl(ptr) >> 24) & 0xFF;
+			ecc_code[i++] = (readl(ptr) >> 16) & 0xFF;
+			ecc_code[i++] = (readl(ptr) >>  8) & 0xFF;
+			ecc_code[i++] = readl(ptr) & 0xFF;
+			ptr--;
+		}
+
+		ptr = &gpmc_cfg->bch_result_0_3[0].bch_result_x[3];
+		for (j = 0; j < 4; j++) {
+			ecc_code[i++] = (readl(ptr) >> 24) & 0xFF;
+			ecc_code[i++] = (readl(ptr) >> 16) & 0xFF;
+			ecc_code[i++] = (readl(ptr) >>  8) & 0xFF;
+			ecc_code[i++] = readl(ptr) & 0xFF;
+			ptr--;
+		}
+
+	} else {
+/* not supported and not used, till now */
+	}
+}
+#endif
+
 /*
  * omap_ecc_disable - Disable H/W ECC calculation
  *
@@ -338,7 +391,11 @@
 		break;
 
 	case ECC_BCH16:
+#ifdef PENGWYN
+		n_bytes = 26;// this should be ok for all, and the 28 is wrong
+#else
 		n_bytes = 28;
+#endif
 		break;
 
 	case ECC_BCH8:
@@ -369,6 +426,13 @@
 	if (bch->type == ECC_BCH8)
 		omap_read_bch8_result(mtd, big_endian, ecc_code);
 	else /* BCH4 and BCH16 currently not supported */
+#ifdef PENGWYN
+	if (bch->type == ECC_BCH16)
+	{
+		omap_read_bch16_result(mtd, big_endian, ecc_code);
+	}
+	else
+#endif
 		ret = -1;
 
 	/*
@@ -649,15 +713,15 @@
 #ifdef CONFIG_AM33XX
 	} else if (hardware == 2) {
 		nand->ecc.mode = NAND_ECC_HW;
-		nand->ecc.layout = &hw_bch8_nand_oob;
-		nand->ecc.size = 512;
-		nand->ecc.bytes = 14;
+		nand->ecc.layout = &hw_bch16_nand_oob;
+		nand->ecc.size = CONFIG_SYS_NAND_ECCSIZE;//pengwyn 512;
+		nand->ecc.bytes = CONFIG_SYS_NAND_ECCBYTES;//pengwyn 26;
 		nand->ecc.read_page = omap_read_page_bch;
 		nand->ecc.hwctl = omap_enable_ecc_bch;
 		nand->ecc.correct = omap_correct_data_bch;
 		nand->ecc.calculate = omap_calculate_ecc_bch;
 		omap_hwecc_init_bch(nand, NAND_ECC_READ);
-		printf("HW BCH8 selected\n");
+		printf("HW BCH16 selected\n");
 #endif
 	} else {
 		nand->ecc.mode = NAND_ECC_SOFT;
@@ -742,7 +806,11 @@
 	/* Default ECC mode */
 #ifdef CONFIG_AM33XX
 	nand->ecc.mode = NAND_ECC_HW;
+#ifdef PENGWYN
+	nand->ecc.layout = &hw_bch16_nand_oob;
+#else
 	nand->ecc.layout = &hw_bch8_nand_oob;
+#endif
 	nand->ecc.size = CONFIG_SYS_NAND_ECCSIZE;
 	nand->ecc.bytes = CONFIG_SYS_NAND_ECCBYTES;
 	nand->ecc.hwctl = omap_enable_ecc_bch;
diff -Naur orig/drivers/net/cpsw.c a/drivers/net/cpsw.c
--- orig/drivers/net/cpsw.c	2012-12-16 20:53:53.000000000 +0100
+++ a/drivers/net/cpsw.c	2014-06-10 17:39:36.634838175 +0200
@@ -734,6 +734,7 @@
 	struct cpsw_slave	*slave;
 	int i, ret;
 
+
 	/* soft reset the controller and initialize priv */
 	setbit_and_wait_for_clear32(&priv->regs->soft_reset);
 
@@ -920,7 +921,11 @@
 			SUPPORTED_100baseT_Full |
 			SUPPORTED_1000baseT_Full);
 
+#ifdef PENGWYN
+	phydev = phy_connect(priv->bus, 1, dev, slave->data->phy_if);
+#else
 	phydev = phy_connect(priv->bus, 0, dev, slave->data->phy_if);
+#endif
 
 	phydev->supported &= supported;
 	phydev->advertising = phydev->supported;
@@ -989,3 +994,4 @@
 
 	return 1;
 }
+
diff -Naur orig/drivers/net/phy/Makefile a/drivers/net/phy/Makefile
--- orig/drivers/net/phy/Makefile	2012-12-16 20:53:53.000000000 +0100
+++ a/drivers/net/phy/Makefile	2014-06-10 17:39:36.634838175 +0200
@@ -42,6 +42,7 @@
 COBJS-$(CONFIG_PHY_SMSC) += smsc.o
 COBJS-$(CONFIG_PHY_TERANETICS) += teranetics.o
 COBJS-$(CONFIG_PHY_VITESSE) += vitesse.o
+COBJS-$(CONFIG_PHY_TI) += ti.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff -Naur orig/drivers/net/phy/phy.c a/drivers/net/phy/phy.c
--- orig/drivers/net/phy/phy.c	2012-12-16 20:53:53.000000000 +0100
+++ a/drivers/net/phy/phy.c	2014-06-10 17:39:36.634838175 +0200
@@ -453,6 +453,9 @@
 #ifdef CONFIG_PHY_VITESSE
 	phy_vitesse_init();
 #endif
+#ifdef CONFIG_PHY_TI
+	phy_ti_init();
+#endif
 
 	return 0;
 }
@@ -569,7 +572,6 @@
 		return -EIO;
 
 	*phy_id |= (phy_reg & 0xffff);
-
 	return 0;
 }
 
@@ -598,7 +600,9 @@
 	/* Try Standard (ie Clause 22) access */
 	r = get_phy_id(bus, addr, MDIO_DEVAD_NONE, &phy_id);
 	if (r)
+{
 		return NULL;
+}
 
 	/* If the PHY ID is mostly f's, we didn't find anything */
 	if ((phy_id & 0x1fffffff) != 0x1fffffff)
@@ -667,6 +671,7 @@
 
 	if (reg & BMCR_RESET) {
 		puts("PHY reset timed out\n");
+		printf("PHY addr 0x%x 0x%x 0x%x\n",phydev->addr, devad, MII_BMCR);
 		return -1;
 	}
 
diff -Naur orig/drivers/net/phy/ti.c a/drivers/net/phy/ti.c
--- orig/drivers/net/phy/ti.c	1970-01-01 01:00:00.000000000 +0100
+++ a/drivers/net/phy/ti.c	2014-06-10 17:39:36.634838175 +0200
@@ -0,0 +1,71 @@
+/*
+ * TI PHY drivers
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Base code from drivers/net/phy/davicom.c
+ *   Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *   author Andy Fleming
+ *
+ * Some code get from linux kenrel
+ * Copyright (c) 2006 Herbert Valerio Riedel <hvr@gnu.org>
+ *
+ */
+#include <miiphy.h>
+
+static int ti_parse_status(struct phy_device *phydev)
+{
+	int mii_reg;
+
+	mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
+
+	if (mii_reg & (BMSR_100FULL | BMSR_100HALF))
+		phydev->speed = SPEED_100;
+	else
+		phydev->speed = SPEED_10;
+
+	if (mii_reg & (BMSR_10FULL | BMSR_100FULL))
+		phydev->duplex = DUPLEX_FULL;
+	else
+		phydev->duplex = DUPLEX_HALF;
+
+	return 0;
+}
+
+static int ti_startup(struct phy_device *phydev)
+{
+//printf("ti_startup\n");
+	genphy_update_link(phydev);
+	ti_parse_status(phydev);
+	return 0;
+}
+
+static struct phy_driver dp83848_driver = {
+	.name = "TI DP83848",
+	.uid = 0x20005c90,//0x0007c0c0,
+	.mask = 0x2000FF90,//0xffff0,
+	.features = PHY_BASIC_FEATURES,
+	.config = &genphy_config_aneg,
+	.startup = &ti_startup,
+	.shutdown = &genphy_shutdown,
+};
+
+int phy_ti_init(void)
+{
+	phy_register(&dp83848_driver);
+
+	return 0;
+}
diff -Naur orig/include/configs/pengwyn.h a/include/configs/pengwyn.h
--- orig/include/configs/pengwyn.h	1970-01-01 01:00:00.000000000 +0100
+++ a/include/configs/pengwyn.h	2014-06-10 17:39:36.634838175 +0200
@@ -0,0 +1,567 @@
+/*
+ * pengwyn.h
+ *
+ * Copyright (C) 2013 silica - http://www.silica.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __CONFIG_PENGWYN_H
+#define __CONFIG_PENGWYN_H
+
+#define CONFIG_AM33XX
+#define PENGWYN
+
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+
+#define CONFIG_DMA_COHERENT
+#define CONFIG_DMA_COHERENT_SIZE	(1 << 20)
+
+#define CONFIG_SYS_MALLOC_LEN		(1024 << 10)
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT		"U-Boot# "
+#define CONFIG_SYS_NO_FLASH
+#define MACH_TYPE_TIAM335EVM		3589	/* Until the next sync */
+#define CONFIG_MACH_TYPE		MACH_TYPE_TIAM335EVM
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+#define CONFIG_SYS_CACHELINE_SIZE       64
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_MTDPARTS
+#define MTDIDS_DEFAULT		"nand0=omap2-nand.0"
+#define MTDPARTS_DEFAULT	"mtdparts=omap2-nand.0:512k(SPL)," \
+				"512k(SPL.backup1),512k(SPL.backup2)," \
+				"512k(SPL.backup3),1536k(u-boot)," \
+				"512k(u-boot-env),12288k(kernel),-(rootfs)" \
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_VERSION_VARIABLE
+
+#if !(defined(CONFIG_USB_SPL) && defined(CONFIG_SPL_BUILD))
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"serverip=192.168.0.20\0" \
+	"ipaddr=192.168.0.101\0" \
+	"loadaddr=0x80200000\0" \
+	"kloadaddr=0x80007fc0\0" \
+	"fdtaddr=0x80F80000\0" \
+	"rdaddr=0x81000000\0" \
+	"bootfile=uImage\0" \
+	"console=ttyO0,115200n8\0" \
+	"optargs=\0" \
+	"mmcdev=0\0" \
+	"mmcroot=/dev/mmcblk0p2 rw\0" \
+	"mmcrootfstype=ext3 rootwait\0" \
+	"nandroot=ubi0:rootfs rw ubi.mtd=7,4096\0" \
+	"nandrootfstype=ubifs rootwait=1\0" \
+	"nandsrcaddr=0x400000\0" \
+	"nandimgsize=0xC00000\0" \
+	"mtdids=" MTDIDS_DEFAULT "\0" \
+	"mtdparts=" MTDPARTS_DEFAULT "\0" \
+	"rootpath=/export/rootfs\0" \
+	"nfsopts=nolock\0" \
+	"ramroot=/dev/ram0 rw ramdisk_size=65536 initrd=${rdaddr},64M\0" \
+	"ramrootfstype=ext2\0" \
+	"ip_method=none\0" \
+	"static_ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}:${hostname}" \
+		"::off\0" \
+	"bootargs_defaults=setenv bootargs " \
+		"console=${console} " \
+		"${optargs}\0" \
+	"mmcargs=run bootargs_defaults;" \
+		"setenv bootargs ${bootargs} " \
+		"root=${mmcroot} " \
+		"rootfstype=${mmcrootfstype} ip=${ip_method}\0" \
+	"nandargs=run bootargs_defaults;" \
+		"setenv bootargs ${bootargs} " \
+		"root=${nandroot} noinitrd " \
+		"rootfstype=${nandrootfstype} ip=${ip_method}\0" \
+	"spiroot=/dev/mtdblock4 rw\0" \
+	"spirootfstype=jffs2\0" \
+	"spisrcaddr=0x80000\0" \
+	"spiimgsize=0x362000\0" \
+	"spibusno=0\0" \
+	"ramroot=/dev/ram0 rw ramdisk_size=65536 initrd=${rdaddr},64M\0" \
+	"ramrootfstype=ext2\0" \
+	"spiargs=run bootargs_defaults;" \
+		"setenv bootargs ${bootargs} " \
+		"rootfstype=${spirootfstype} ip=${ip_method}\0" \
+	"netargs=run bootargs_defaults;" \
+		"setenv bootargs ${bootargs} " \
+		"root=/dev/nfs " \
+		"nfsroot=${serverip}:${rootpath},${nfsopts} rw " \
+		"ip=dhcp\0" \
+	"bootenv=uEnv.txt\0" \
+	"loadbootenv=fatload mmc ${mmcdev} ${loadaddr} ${bootenv}\0" \
+	"importbootenv=echo Importing environment from mmc ...; " \
+		"env import -t $loadaddr $filesize\0" \
+	"ramargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${ramroot} " \
+		"rootfstype=${ramrootfstype}\0" \
+	"loadramdisk=fatload mmc ${mmcdev} ${rdaddr} ramdisk.gz\0" \
+	"loaduimagefat=fatload mmc ${mmcdev} ${kloadaddr} ${bootfile}\0" \
+	"loaduimage=ext2load mmc ${mmcdev}:2 ${kloadaddr} /boot/${bootfile}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${kloadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read.i ${kloadaddr} ${nandsrcaddr} ${nandimgsize}; " \
+		"bootm ${kloadaddr}\0" \
+	"spiboot=echo Booting from spi ...; " \
+		"run spiargs; " \
+		"sf probe ${spibusno}:0; " \
+		"sf read ${kloadaddr} ${spisrcaddr} ${spiimgsize}; " \
+		"bootm ${kloadaddr}\0" \
+	"netboot=echo Booting from network ...; " \
+		"setenv autoload no; " \
+		"dhcp; " \
+		"tftp ${kloadaddr} ${bootfile}; " \
+		"run netargs; " \
+		"bootm ${kloadaddr}\0" \
+	"ramboot=echo Booting from ramdisk ...; " \
+		"run ramargs; " \
+		"bootm ${loadaddr}\0" \
+	"nandupdate=nand erase 0 1000000; " \
+		"mw 80000000 ffffffff 1000000; " \
+		"fatload mmc 0 80000000 mlo; " \
+		"fatload mmc 0 80080000 mlo; " \
+		"fatload mmc 0 80100000 mlo; " \
+		"fatload mmc 0 80180000 mlo; " \
+		"fatload mmc 0 80200000 u-boot.img; " \
+		"fatload mmc 0 80400000 uImage; " \
+		"setenv nandimgsize $filesize; " \
+		"nand write 80000000 0 1000000; " \
+		"saveenv\0" \
+    CONFIG_DFU_ALT
+
+/* set to negative value for no autoboot */
+#define CONFIG_BOOTDELAY		2
+
+#define CONFIG_BOOTCOMMAND \
+	"if mmc rescan ${mmcdev}; then " \
+		"echo SD/MMC found on device ${mmcdev};" \
+		"if run loadbootenv; then " \
+			"echo Loaded environment from ${bootenv};" \
+			"run importbootenv;" \
+		"fi;" \
+		"if test -n $uenvcmd; then " \
+			"echo Running uenvcmd ...;" \
+			"run uenvcmd;" \
+		"fi;" \
+		"if run loaduimagefat; then " \
+			"run mmcboot;" \
+		"elif run loaduimage; then " \
+			"run mmcboot;" \
+		"else " \
+			"echo Cound not find ${bootfile} ;" \
+		"fi;" \
+	"else " \
+		"run nandboot;" \
+	"fi;" \
+
+#else
+#define CONFIG_BOOTDELAY		0
+
+#define CONFIG_BOOTCOMMAND			\
+	"setenv autoload no; "			\
+	"dhcp; "				\
+	"if tftp 80000000 debrick.scr; then "	\
+		"source 80000000; "		\
+	"fi"
+#endif
+
+/* Clock Defines */
+#define V_OSCK				24000000  /* Clock output from T2 */
+#define V_SCLK				(V_OSCK)
+
+#define CONFIG_CMD_ECHO
+
+/* max number of command args */
+#define CONFIG_SYS_MAXARGS		16
+
+/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE \
+					+ sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+/*
+ * memtest works on 8 MB in DRAM after skipping 32MB from
+ * start addr of ram disk
+ */
+#define CONFIG_SYS_MEMTEST_START	(PHYS_DRAM_1 + (64 * 1024 * 1024))
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START \
+					+ (8 * 1024 * 1024))
+
+#define CONFIG_SYS_LOAD_ADDR		0x81000000 /* Default load address */
+#define CONFIG_SYS_HZ			1000 /* 1ms clock */
+
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_OMAP_HSMMC
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_EXT2
+#define CONFIG_FAT_WRITE
+
+#define CONFIG_SPI
+#define CONFIG_OMAP3_SPI
+#define CONFIG_MTD_DEVICE
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_WINBOND
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED		(24000000)
+
+/* USB Composite download gadget - g_dnl */
+#define CONFIG_USB_GADGET
+#define CONFIG_USBDOWNLOAD_GADGET
+
+
+/* USB TI's IDs */
+#define CONFIG_USBD_HS
+#define CONFIG_G_DNL_VENDOR_NUM 0x0403
+#define CONFIG_G_DNL_PRODUCT_NUM 0xBD00
+#define CONFIG_G_DNL_MANUFACTURER "Texas Instruments"
+
+/* USB Device Firmware Update (DFU) support */
+#define DFU_ALT_INFO_NAND \
+	"dfu_alt_info=" \
+	"SPL part 0 1;" \
+	"SPL.backup1 part 0 2;" \
+	"SPL.backup2 part 0 3;" \
+	"SPL.backup3 part 0 4;" \
+	"u-boot part 0 5;" \
+	"kernel part 0 7;" \
+	"rootfs part 0 8\0" \
+
+#define DFU_ALT_INFO_MMC \
+	"dfu_alt_info=" \
+	"boot part 0 1;" \
+	"rootfs part 0 2;" \
+	"MLO fat 0 1;" \
+	"u-boot.img fat 0 1;" \
+	"uEnv.txt fat 0 1\0"
+
+#define CONFIG_DFU_FUNCTION
+#ifdef CONFIG_DFU_MMC
+#define CONFIG_DFU_ALT			DFU_ALT_INFO_MMC
+#elif CONFIG_DFU_NAND
+#endif
+#define CONFIG_DFU_ALT			DFU_ALT_INFO_NAND
+#define CONFIG_CMD_DFU
+
+/* CPSW ethernet */
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_PING
+#define CONFIG_DRIVER_TI_CPSW
+#define CONFIG_MII
+#define CONFIG_BOOTP_DEFAULT
+#define CONFIG_BOOTP_DNS
+#define CONFIG_BOOTP_DNS2
+#define CONFIG_BOOTP_SEND_HOSTNAME
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_NET_RETRY_COUNT         10
+#define CONFIG_NET_MULTI
+/*#define CONFIG_PHY_GIGE*/
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_TI
+#define CONFIG_PHY_REALTEK
+
+ /* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1		/*  1 bank of DRAM */
+#define PHYS_DRAM_1			0x80000000	/* DRAM Bank #1 */
+#define CONFIG_MAX_RAM_BANK_SIZE	(1024 << 20)	/* 1GB */
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_DRAM_1
+#define CONFIG_SYS_INIT_SP_ADDR         (NON_SECURE_SRAM_END - \
+						GENERATED_GBL_DATA_SIZE)
+ /* Platform/Board specific defs */
+#define CONFIG_SYS_TIMERBASE		0x48040000	/* Use Timer2 */
+#define CONFIG_SYS_PTV			2	/* Divisor: 2^(PTV+1) => 8 */
+#define CONFIG_SYS_HZ			1000
+
+/* NS16550 Configuration */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		(48000000)
+#define CONFIG_SYS_NS16550_COM1		0x44e09000	/* Base EVM has UART0 */
+
+/* I2C Configuration */
+#define CONFIG_I2C
+#define CONFIG_CMD_I2C
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_DRIVER_OMAP24XX_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_ENV_EEPROM_IS_ON_I2C
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50	/* Main EEPROM */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	2
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+
+#define CONFIG_OMAP_GPIO
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 110, 300, 600, 1200, 2400, \
+4800, 9600, 14400, 19200, 28800, 38400, 56000, 57600, 115200 }
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_CONSOLE_INFO_QUIET
+
+#define CONFIG_ENV_IS_NOWHERE
+
+/* NAND Configuration. */
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_PAGE_COUNT	(CONFIG_SYS_NAND_BLOCK_SIZE / \
+					 CONFIG_SYS_NAND_PAGE_SIZE)
+#define CONFIG_SYS_NAND_PAGE_SIZE	4096 // 2048
+#define CONFIG_SYS_NAND_OOBSIZE		224 // 64
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128*4096)
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS	NAND_LARGE_BADBLOCK_POS
+#define CONFIG_SYS_NAND_ECCPOS		{  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,	16, 17,\
+									18, 19, 20, 21, 22, 23, 24, 25, 26, 27,	28, 29, 30, 31, 32, 33,\
+									34, 35, 36, 37, 38, 39,	40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
+									50, 51,	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,	63, 64, 65,\
+									66, 67, 68, 69, 70, 71, 72, 73, 74,	75, 76, 77, 78, 79, 80, 81,\
+									82, 83, 84, 85, 86,	87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,\
+									98,	99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,\
+									114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,\
+									134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,\
+									154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,\
+									174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,\
+									194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209}
+
+
+#define CONFIG_SYS_NAND_ECCSIZE		512
+#define CONFIG_SYS_NAND_ECCBYTES	26
+#define CONFIG_SYS_NAND_ECCSTEPS	8
+#define	CONFIG_SYS_NAND_ECCTOTAL	(CONFIG_SYS_NAND_ECCBYTES * \
+									CONFIG_SYS_NAND_ECCSTEPS)
+
+
+#ifndef CONFIG_NOR_BOOT
+/* Defines for SPL */
+#define CONFIG_SPL
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_TEXT_BASE		0x402F0400
+#define CONFIG_SPL_MAX_SIZE		(101 * 1024)
+#define CONFIG_SPL_STACK		CONFIG_SYS_INIT_SP_ADDR
+
+#define CONFIG_SPL_LDSCRIPT		"$(CPUDIR)/omap-common/u-boot-spl.lds"
+#define CONFIG_SPL_BSS_START_ADDR	0x80000000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000		/* 512 KB */
+
+/* Core features. */
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_BOARD_INIT
+#define CONFIG_SPL_GPIO_SUPPORT
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_PANIC_HANG		/* Do not call do_reset() */
+#endif
+
+/* Core network SPL (USB and CPSW). */
+#define CONFIG_SPL_NET_SUPPORT
+#define CONFIG_SPL_NET_VCI_STRING	"Pengwyn U-Boot SPL"
+
+/* USB (RNDIS) SPL */
+#ifdef CONFIG_USB_SPL
+#define CONFIG_SPL_MUSB_GADGET_SUPPORT
+#define CONFIG_SPL_USB_ETH_SUPPORT
+#ifdef CONFIG_SPL_BUILD
+#undef CONFIG_PHYLIB			/* Only needed on CPSW */
+#endif
+#endif
+
+/*
+ * Due to size constraints we need to limit what goes into the USB SPL.
+ * For now we allow either USB or CPSW but not both.  This is OK as the
+ * ROM will only support booting over one in a given configuration as well.
+ */
+#ifndef CONFIG_USB_SPL
+/* CPSW SPL */
+#define CONFIG_SPL_ETH_SUPPORT
+#endif
+
+/* SD/MMC/eMMC */
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR	0x300 /* address 0x60000 */
+#define CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS	0x200 /* 256 KB */
+#define CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION	1
+#define CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME	"u-boot.img"
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_FAT_SUPPORT
+#define CONFIG_SPL_LIBDISK_SUPPORT
+
+/* Y-Modem. */
+#define CONFIG_SPL_YMODEM_SUPPORT
+
+/* SPI */
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_LOAD
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		0
+#define CONFIG_SYS_SPI_U_BOOT_OFFS	0x20000
+
+/* NAND */
+#define CONFIG_SPL_NAND_AM33XX_BCH
+#define CONFIG_SPL_NAND_SUPPORT
+#define	CONFIG_SYS_NAND_U_BOOT_START	CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_NAND_U_BOOT_OFFS		0x200000
+#endif
+
+/*
+ * 1MB into the SDRAM to allow for SPL's bss at the beginning of SDRAM
+ * 64 bytes before this address should be set aside for u-boot.img's
+ * header. That is 0x800FFFC0--0x80100000 should not be used for any
+ * other needs.
+ */
+#ifdef CONFIG_NOR_BOOT
+#define CONFIG_SYS_TEXT_BASE		0x08000000
+#else
+#define CONFIG_SYS_TEXT_BASE		0x80800000
+#endif
+#define CONFIG_SYS_SPL_MALLOC_START	0x80208000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+
+/* Since SPL did pll and ddr initialization for us,
+ * we don't need to do it twice.
+ */
+#if !defined(CONFIG_SPL_BUILD) && !defined(CONFIG_NOR_BOOT)
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#endif
+
+/*
+ * USB configuration
+ */
+
+#define CONFIG_USB_MUSB_DSPS
+#define CONFIG_ARCH_MISC_INIT
+#define CONFIG_MUSB_GADGET
+#define CONFIG_MUSB_PIO_ONLY
+#define CONFIG_USB_GADGET_DUALSPEED
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+#define CONFIG_MUSB_HOST
+#define CONFIG_AM335X_USB0
+#define CONFIG_AM335X_USB0_MODE	MUSB_PERIPHERAL
+#define CONFIG_AM335X_USB1
+#define CONFIG_AM335X_USB1_MODE MUSB_HOST
+
+#ifdef CONFIG_MUSB_HOST
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#endif
+
+#ifdef CONFIG_MUSB_GADGET
+/*#define CONFIG_USB_ETHER*/
+#define CONFIG_USB_ETH_RNDIS
+#define CONFIG_USBNET_DEV_ADDR	"aa:bb:cc:00:11:33"
+#define CONFIG_USBNET_HOST_ADDR	"aa:bb:cc:00:11:44"
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_TFTP
+#endif /* CONFIG_MUSB_GADGET */
+
+/* ENV in SPI */
+#if defined(CONFIG_SPI_BOOT)
+# undef CONFIG_ENV_IS_NOWHERE
+# define CONFIG_ENV_IS_IN_SPI_FLASH
+# define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+# define CONFIG_ENV_OFFSET		(508 << 10) /* 508 KB in */
+# define CONFIG_ENV_SECT_SIZE		(4 << 10) /* 4 KB sectors */
+# define CONFIG_ENV_SIZE		CONFIG_ENV_SECT_SIZE
+#endif /* SPI support */
+
+/* Unsupported features */
+#undef CONFIG_USE_IRQ
+
+#define CONFIG_NAND
+/* NAND support */
+#ifdef CONFIG_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_NAND_OMAP_GPMC
+/*#define GPMC_NAND_ECC_LP_x16_LAYOUT	1*/
+#define GPMC_NAND_ECC_LP_x8_LAYOUT	1
+#define CONFIG_SYS_NAND_BASE		(0x08000000)	/* physical address */
+							/* to access nand at */
+							/* CS0 */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of NAND
+							   devices */
+#if !defined(CONFIG_SPI_BOOT) && !defined(CONFIG_NOR_BOOT)
+#undef CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET		(7*CONFIG_SYS_NAND_BLOCK_SIZE) /* environment starts here */
+#define CONFIG_ENV_SIZE			(CONFIG_SYS_NAND_BLOCK_SIZE)	/* 512 KiB */
+#endif
+#endif
+
+/*
+ * NOR Size = 16 MB
+ * No.Of Sectors/Blocks = 128
+ * Sector Size = 128 KB
+ * Word lenght = 16 bits
+ */
+#if defined(CONFIG_NOR)
+#undef CONFIG_SYS_NO_FLASH
+#undef CONFIG_SYS_MALLOC_LEN
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_MALLOC_LEN		(0x100000)
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_FLASH_CFI_MTD
+#define CONFIG_SYS_MAX_FLASH_SECT	128
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_BASE		(0x08000000)
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_FLASH_BASE
+#define NOR_SECT_SIZE			(128 * 1024)
+#ifdef CONFIG_NOR_BOOT
+#undef CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_SYS_ENV_SECT_SIZE	(2 * NOR_SECT_SIZE)
+#define CONFIG_ENV_SECT_SIZE		(2 * NOR_SECT_SIZE)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_OFFSET		(2 * NOR_SECT_SIZE) /* After 1 MB */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + \
+	 CONFIG_ENV_OFFSET)
+#endif
+#define CONFIG_MTD_DEVICE
+#define CONFIG_CMD_FLASH
+#endif	/* NOR support */
+
+#endif	/* ! __CONFIG_PENGWYN_H */
+
diff -Naur orig/include/linux/mtd/mtd-abi.h a/include/linux/mtd/mtd-abi.h
--- orig/include/linux/mtd/mtd-abi.h	2012-12-16 20:53:53.000000000 +0100
+++ a/include/linux/mtd/mtd-abi.h	2014-06-10 17:39:36.638840174 +0200
@@ -123,7 +123,11 @@
  */
 struct nand_ecclayout {
 	uint32_t eccbytes;
+#ifdef PENGWYN
+	uint32_t eccpos[CONFIG_SYS_NAND_OOBSIZE];
+#else
 	uint32_t eccpos[128];
+#endif
 	uint32_t oobavail;
 	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
 };
